<canvas id="lifeCanvas"></canvas>

<style>
  /* Fix the canvas to the background */
  #lifeCanvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1; /* Puts it behind everything */
    opacity: 0.3; /* Makes it subtle */
    pointer-events: none; /* Lets clicks pass through to your links */
  }
</style>

<script>
  const canvas = document.getElementById('lifeCanvas');
  const ctx = canvas.getContext('2d');
  
  let width, height, columns, rows;
  const cellSize = 20; 
  let grid, nextGrid;
  
  // Track the width to ignore vertical-only resizes (mobile scrolling)
  let lastWidth = window.innerWidth; 

  function initGrid() {
    grid = new Array(columns).fill(null).map(() => new Array(rows).fill(0));
    nextGrid = new Array(columns).fill(null).map(() => new Array(rows).fill(0));
    
    for (let i = 0; i < columns; i++) {
      for (let j = 0; j < rows; j++) {
        // Density 0.7 means 30% alive (flipped logic), or keep your preferred > 0.8
        grid[i][j] = Math.random() > 0.8 ? 1 : 0; 
      }
    }
  }

  function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
    columns = Math.floor(width / cellSize);
    rows = Math.floor(height / cellSize);
    initGrid();
  }

  function draw() {
    ctx.fillStyle = '#ffffff'; 
    ctx.fillRect(0, 0, width, height);
    
    // Your preferred opacity
    ctx.fillStyle = 'rgba(0, 0, 0, 0.10)';
    for (let i = 0; i < columns; i++) {
      for (let j = 0; j < rows; j++) {
        if (grid[i][j] === 1) {
          ctx.fillRect(i * cellSize, j * cellSize, cellSize - 1, cellSize - 1);
        }
      }
    }
  }

  function update() {
    for (let x = 0; x < columns; x++) {
      for (let y = 0; y < rows; y++) {
        let neighbors = 0;
        for (let i = -1; i <= 1; i++) {
          for (let j = -1; j <= 1; j++) {
            if (i === 0 && j === 0) continue;
            const col = (x + i + columns) % columns;
            const row = (y + j + rows) % rows;
            neighbors += grid[col][row];
          }
        }
        if (grid[x][y] === 1 && (neighbors < 2 || neighbors > 3)) nextGrid[x][y] = 0;
        else if (grid[x][y] === 0 && neighbors === 3) nextGrid[x][y] = 1;
        else nextGrid[x][y] = grid[x][y];
      }
    }
    let temp = grid;
    grid = nextGrid;
    nextGrid = temp;
  }

  const tickDelay = 200; 

  function loop() {
    setTimeout(() => {
        draw();
        update();
        requestAnimationFrame(loop);
    }, tickDelay);
  }

  // --- THE FIX IS HERE ---
  // Instead of passing resize directly, we check if width changed
  window.addEventListener('resize', () => {
      // If width is different, it means we rotated phone or resized desktop window
      if (window.innerWidth !== lastWidth) {
          lastWidth = window.innerWidth;
          resize();
      }
      // If only height changed (scrolling), do nothing!
  });

  // Initial setup
  resize();
  loop();
</script>